#!/usr/bin/env python3
"""
Script to split the large app.py file into smaller, more manageable modules
"""
import os
import re
import shutil

def create_directory_structure():
    """Create the necessary directory structure"""
    os.makedirs("app", exist_ok=True)
    os.makedirs("app/routes", exist_ok=True)
    
    # Create __init__.py to make it a package
    init_content = """# app package
# This file was auto-generated by split_app.py

from .core import create_app

# Import all modules to make their functions available
from . import scan_engine
from . import utils
from . import email
from .routes import index, api
"""
    
    with open(os.path.join("app", "__init__.py"), "w") as f:
        f.write(init_content)
    
    routes_init_content = """# app.routes package
# This file was auto-generated by split_app.py

# Import all route modules
from . import index, api
"""
    
    with open(os.path.join("app", "routes", "__init__.py"), "w") as f:
        f.write(routes_init_content)
    
    print("✅ Created directory structure")

def extract_app_core(source_file, target_file):
    """Extract the core app initialization code"""
    with open(source_file, "r") as f:
        content = f.read()
    
    # Extract imports, app initialization, config
    imports = re.search(r'(import.*?)# Configure logging', content, re.DOTALL)
    if not imports:
        print("❌ Could not find imports section")
        return False
    
    config = re.search(r'(# Configure logging.*?)# Utility functions', content, re.DOTALL)
    if not config:
        print("❌ Could not find configuration section")
        return False
    
    # Find the app creation and setup
    app_setup = re.search(r'(# Create Flask app.*?)# Route definitions', content, re.DOTALL)
    if not app_setup:
        print("❌ Could not find app setup section")
        return False
    
    # Create the new file
    with open(target_file, "w") as f:
        # Add module docstring
        f.write('"""\napp.core - Core application initialization and configuration\n"""\n\n')
        
        # Add imports with some modifications
        imports_text = imports.group(1)
        # Replace direct imports with relative imports where needed
        imports_text = imports_text.replace("from client_db", "from db")
        f.write(imports_text + "\n")
        
        # Add configuration section
        f.write(config.group(1) + "\n")
        
        # Create a create_app function to wrap the app setup
        f.write("def create_app():\n    \"\"\"\n    Create and configure the Flask application\n    \"\"\"\n")
        
        # Indent the app setup code and add it to the function
        app_text = app_setup.group(1)
        app_text = "    " + app_text.replace("\n", "\n    ")
        f.write(app_text + "\n")
        
        # Add return statement
        f.write("    return app\n\n")
        
        # Add standalone code section
        f.write('# Create application instance when this module is run directly\n')
        f.write('if __name__ == "__main__":\n')
        f.write('    app = create_app()\n')
        f.write('    app.run(debug=True)\n')
    
    print(f"✅ Created {target_file}")
    return True

def extract_scan_engine(source_file, target_file):
    """Extract the scanning engine functions"""
    with open(source_file, "r") as f:
        content = f.read()
    
    # Define the functions to extract
    scan_functions = [
        "scan_gateway_ports",
        "check_ssl_certificate",
        "check_security_headers",
        "detect_cms",
        "analyze_cookies",
        "detect_web_framework",
        "crawl_for_sensitive_content",
        "analyze_dns_configuration",
        "check_spf_status",
        "check_dmarc_record",
        "check_dkim_record"
    ]
    
    # Create a regex pattern to match these functions
    pattern = "|".join([f"def {func}" for func in scan_functions])
    
    # Find all scan engine functions
    functions = []
    for func in scan_functions:
        func_pattern = f"def {func}.*?(?=def \w+:|$)"
        func_match = re.search(func_pattern, content, re.DOTALL)
        if func_match:
            functions.append(func_match.group(0))
    
    if not functions:
        print("❌ No scanning functions found")
        return False
    
    # Create the new file
    with open(target_file, "w") as f:
        # Add module docstring
        f.write('"""\napp.scan_engine - Security scanning functionality\n"""\n\n')
        
        # Add necessary imports
        f.write('import requests\nimport socket\nimport re\nimport ssl\nimport json\nimport dns.resolver\nimport subprocess\nfrom datetime import datetime\nfrom urllib.parse import urlparse\nfrom bs4 import BeautifulSoup\n\n')
        
        # Add all the functions
        for func in functions:
            f.write(func + "\n\n")
    
    print(f"✅ Created {target_file} with {len(functions)} functions")
    return True

def extract_utils(source_file, target_file):
    """Extract utility functions"""
    with open(source_file, "r") as f:
        content = f.read()
    
    # Define the utility functions to extract
    util_functions = [
        "secure_filename",
        "extract_domain_from_email",
        "server_lookup",
        "get_client_and_gateway_ip",
        "get_default_gateway_ip",
        "is_valid_email",
        "generate_random_string"
    ]
    
    # Find all utility functions
    functions = []
    for func in util_functions:
        func_pattern = f"def {func}.*?(?=def \w+:|$)"
        func_match = re.search(func_pattern, content, re.DOTALL)
        if func_match:
            functions.append(func_match.group(0))
    
    if not functions:
        print("❌ No utility functions found")
        return False
    
    # Create the new file
    with open(target_file, "w") as f:
        # Add module docstring
        f.write('"""\napp.utils - Utility functions for the application\n"""\n\n')
        
        # Add necessary imports
        f.write('import os\nimport re\nimport socket\nimport random\nimport string\nfrom urllib.parse import urlparse\nimport werkzeug\n\n')
        
        # Add all the functions
        for func in functions:
            f.write(func + "\n\n")
    
    print(f"✅ Created {target_file} with {len(functions)} functions")
    return True

def extract_email_functions(source_file, target_file):
    """Extract email-related functions"""
    with open(source_file, "r") as f:
        content = f.read()
    
    # Define the email functions to extract
    email_functions = [
        "send_email_report",
        "send_notification",
        "send_security_alert",
        "format_email_template"
    ]
    
    # Find all email functions
    functions = []
    for func in email_functions:
        func_pattern = f"def {func}.*?(?=def \w+:|$)"
        func_match = re.search(func_pattern, content, re.DOTALL)
        if func_match:
            functions.append(func_match.group(0))
    
    if not functions:
        print("❌ No email functions found")
        return False
    
    # Create the new file
    with open(target_file, "w") as f:
        # Add module docstring
        f.write('"""\napp.email - Email functionality for the application\n"""\n\n')
        
        # Add necessary imports
        f.write('import os\nimport smtplib\nimport logging\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nfrom jinja2 import Environment, FileSystemLoader\n\n')
        
        # Add all the functions
        for func in functions:
            f.write(func + "\n\n")
    
    print(f"✅ Created {target_file} with {len(functions)} functions")
    return True

def extract_routes(source_file, target_files):
    """Extract routes into separate modules"""
    with open(source_file, "r") as f:
        content = f.read()
    
    # Define the route groups
    route_groups = {
        "index": {
            "file": target_files["index"],
            "pattern": r'@app.route\([\'"]/(?!api)[^\'"]*[\'"].*?\)(?:\s+@.*?\))*\s+def\s+(?!api_)[^\(]+\([^\)]*\):.*?(?=@app\.route|\Z)',
            "imports": [
                "from flask import Blueprint, render_template, request, redirect, url_for, flash, session",
                "from db import get_client_by_user_id, verify_session"
            ]
        },
        "api": {
            "file": target_files["api"],
            "pattern": r'@app.route\([\'"]\/api[^\'"]*[\'"].*?\)(?:\s+@.*?\))*\s+def\s+api_[^\(]+\([^\)]*\):.*?(?=@app\.route|\Z)',
            "imports": [
                "from flask import Blueprint, request, jsonify",
                "from db import get_scan_results, format_scan_results_for_client"
            ]
        }
    }
    
    # Process each route group
    for group_name, group_info in route_groups.items():
        # Find all routes for this group
        route_matches = re.findall(group_info["pattern"], content, re.DOTALL)
        
        if not route_matches:
            print(f"❌ No {group_name} routes found")
            continue
        
        # Create blueprint
        bp_name = f"{group_name}_bp"
        
        # Create the new file
        with open(group_info["file"], "w") as f:
            # Add module docstring
            f.write(f'"""\napp.routes.{group_name} - {group_name.capitalize()} routes\n"""\n\n')
            
            # Add imports
            for imp in group_info["imports"]:
                f.write(f'{imp}\n')
            
            # Create blueprint
            f.write(f'\n{bp_name} = Blueprint("{group_name}", __name__)\n\n')
            
            # Add all routes, converting from app.route to blueprint route
            for route in route_matches:
                # Replace @app.route with @blueprint.route
                modified_route = route.replace("@app.route", f"@{bp_name}.route")
                f.write(modified_route + "\n\n")
            
            # Add function to register blueprint
            f.write(f'def register_{group_name}_routes(app):\n')
            f.write(f'    """\n    Register {group_name} routes with the app\n    """\n')
            f.write(f'    app.register_blueprint({bp_name})\n')
        
        print(f"✅ Created {group_info['file']} with {len(route_matches)} routes")

def create_proxy_app(target_file):
    """Create a proxy app.py file that imports from the new modular structure"""
    proxy_content = """# app.py - Proxy for backwards compatibility
# This file was auto-generated by split_app.py

from app import create_app

# Create the Flask application
app = create_app()

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=5000)
"""
    
    with open(target_file, "w") as f:
        f.write(proxy_content)
    
    print(f"✅ Created proxy {target_file}")

def create_wsgi_file():
    """Create a wsgi.py file for production deployment"""
    wsgi_content = """# wsgi.py - WSGI entry point for production deployment
# This file was auto-generated by split_app.py

from app import create_app

# Create the Flask application
application = create_app()

if __name__ == "__main__":
    application.run()
"""
    
    with open("wsgi.py", "w") as f:
        f.write(wsgi_content)
    
    print("✅ Created wsgi.py for production deployment")

def main():
    """Main function to split app.py into modules"""
    print("Starting to split app.py into modules...")
    
    # Create a backup of the original file
    shutil.copy2("app.py", "app.py.bak")
    print("✅ Created backup of app.py")
    
    # Create directory structure
    create_directory_structure()
    
    # Extract core app functionality
    extract_app_core("app.py", "app/core.py")
    
    # Extract scan engine functions
    extract_scan_engine("app.py", "app/scan_engine.py")
    
    # Extract utility functions
    extract_utils("app.py", "app/utils.py")
    
    # Extract email functions
    extract_email_functions("app.py", "app/email.py")
    
    # Extract routes
    route_files = {
        "index": "app/routes/index.py",
        "api": "app/routes/api.py"
    }
    extract_routes("app.py", route_files)
    
    # Create proxy app.py
    create_proxy_app("app.py.new")
    
    # Create wsgi.py
    create_wsgi_file()
    
    print("\n✅ Process complete! To finalize the changes:")
    print("1. Verify that all functions were extracted correctly")
    print("2. Check imports in the new module files")
    print("3. Replace the original app.py with app.py.new")
    print("\nYou can do this by running:")
    print("  mv app.py.new app.py")

if __name__ == "__main__":
    main()