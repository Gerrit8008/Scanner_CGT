#!/usr/bin/env python3
"""
Script to split the large client_db.py file into smaller, more manageable modules
"""
import os
import re
import shutil

# Make sure the directory structure exists
def create_directory_structure():
    """Create the necessary directory structure"""
    os.makedirs("db", exist_ok=True)
    
    # Create __init__.py to make it a package
    init_content = """# db package
# This file was auto-generated by split_client_db.py

from .core import *
from .client import *
from .scanner import *
from .scan_results import *
from .dashboard import *
from .audit import *
from .auth import *

# Initialize the database on import
init_client_db()
"""
    
    with open(os.path.join("db", "__init__.py"), "w") as f:
        f.write(init_content)
    
    print("✅ Created directory structure")

# Function to extract specific functions from client_db.py
def extract_functions(source_file, pattern, target_file, module_name, imports=None, add_docstring=None):
    """Extract functions from source_file and write to target_file"""
    with open(source_file, "r") as f:
        content = f.read()
    
    # Find all functions matching the pattern
    matches = re.findall(pattern, content, re.DOTALL)
    
    if not matches:
        print(f"❌ No functions found matching pattern: {pattern}")
        return False
    
    # Create the new module file
    with open(target_file, "w") as f:
        # Add the module docstring
        f.write(f'"""\n{module_name} - Functions for {module_name.lower()} operations\n')
        if add_docstring:
            f.write(f"\n{add_docstring}\n")
        f.write('"""\n\n')
        
        # Add imports
        f.write('import os\nimport sqlite3\nimport logging\nfrom datetime import datetime\n')
        if imports:
            for imp in imports:
                f.write(f'{imp}\n')
        f.write('\n')
        
        # Extract CLIENT_DB_PATH from client_db.py
        client_db_path_match = re.search(r'CLIENT_DB_PATH\s*=\s*.*', content)
        if client_db_path_match:
            f.write(f"{client_db_path_match.group(0)}\n\n")
        
        # Extract with_transaction decorator if needed
        if "with_transaction" in str(matches):
            with_transaction_match = re.search(r'def with_transaction.*?return wrapper', content, re.DOTALL)
            if with_transaction_match:
                f.write(f"{with_transaction_match.group(0)}\n\n")
        
        # Add all the functions
        for func in matches:
            f.write(f"{func}\n\n")
    
    print(f"✅ Created {target_file} with {len(matches)} functions")
    return True

def main():
    """Main function to split client_db.py into modules"""
    print("Starting to split client_db.py into modules...")
    
    # Create a backup of the original file
    shutil.copy2("client_db.py", "client_db.py.bak")
    print("✅ Created backup of client_db.py")
    
    # Create directory structure
    create_directory_structure()
    
    # Define the modules and their function patterns
    modules = [
        {
            "name": "core",
            "file": "db/core.py",
            "pattern": r'def (get_db_connection|init_client_db|with_transaction).*?(?=def \w+|$)',
            "docstring": "Core database functionality including connection management and transaction handling.",
            "imports": []
        },
        {
            "name": "client",
            "file": "db/client.py",
            "pattern": r'def (get_client_by_user_id|get_client_by_id|list_clients|update_client|register_client|deactivate_client|reactivate_client|delete_client|create_client).*?(?=def \w+|$)',
            "docstring": "Functions for managing client records in the database.",
            "imports": ["from .core import get_db_connection, with_transaction"]
        },
        {
            "name": "scanner",
            "file": "db/scanner.py",
            "pattern": r'def (get_deployed_scanners_by_client_id|get_scanner_by_id|update_scanner_config|regenerate_scanner_api_key|create_scanner|delete_scanner).*?(?=def \w+|$)',
            "docstring": "Functions for managing scanner configurations and deployments.",
            "imports": ["from .core import get_db_connection, with_transaction"]
        },
        {
            "name": "scan_results",
            "file": "db/scan_results.py",
            "pattern": r'def (get_scan_history_by_client_id|get_scan_results|format_scan_results_for_client|log_scan|get_scan_history|get_scan_reports_for_client|save_scan_results).*?(?=def \w+|$)',
            "docstring": "Functions for managing scan results and reports.",
            "imports": ["from .core import get_db_connection, with_transaction", "import json", "import re"]
        },
        {
            "name": "dashboard",
            "file": "db/dashboard.py",
            "pattern": r'def (get_client_dashboard_data|get_client_statistics|get_dashboard_summary|get_recent_activities|get_available_scanners_for_client|get_scan_statistics_for_client).*?(?=def \w+|$)',
            "docstring": "Functions for retrieving dashboard data and statistics.",
            "imports": ["from .core import get_db_connection, with_transaction", "from .scanner import get_deployed_scanners_by_client_id", "from .scan_results import get_scan_history_by_client_id"]
        },
        {
            "name": "audit",
            "file": "db/audit.py",
            "pattern": r'def (add_audit_log|track_activity|get_audit_logs).*?(?=def \w+|$)',
            "docstring": "Functions for audit logging and activity tracking.",
            "imports": ["from .core import get_db_connection, with_transaction"]
        },
        {
            "name": "auth",
            "file": "db/auth.py",
            "pattern": r'def (verify_session|create_session|destroy_session|validate_api_key).*?(?=def \w+|$)',
            "docstring": "Functions for authentication and session management.",
            "imports": ["from .core import get_db_connection, with_transaction"]
        }
    ]
    
    # Extract functions for each module
    for module in modules:
        extract_functions(
            "client_db.py",
            module["pattern"],
            module["file"],
            module["name"],
            module["imports"],
            module["docstring"]
        )
    
    # Create a proxy client_db.py that imports from the new modules
    proxy_content = """# client_db.py - Proxy for backwards compatibility
# This file was auto-generated by split_client_db.py

# Import all functions from the new modular structure
from db import *

print("Using modular database structure. Direct imports from client_db.py are deprecated.")
"""
    
    with open("client_db.py.new", "w") as f:
        f.write(proxy_content)
    
    print("\n✅ Created proxy client_db.py.new file")
    print("\nProcess complete! To finalize the changes:")
    print("1. Verify that all functions were extracted correctly")
    print("2. Check imports in the new module files")
    print("3. Replace the original client_db.py with client_db.py.new")
    print("4. Update imports in other files to use the new module structure")
    print("\nYou can do this by running:")
    print("  mv client_db.py.new client_db.py")

if __name__ == "__main__":
    main()